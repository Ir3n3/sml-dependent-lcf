\documentclass[11pt]{article}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amsmath, amssymb, amsthm, stmaryrd, scalerel}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{unicode-math}
\usepackage{xltxtra}
\usepackage{xunicode}

\usepackage{setspace,url,hyperref}

\definecolor{dark-gray}{gray}{0.20}

% fonts
% \setromanfont[Mapping=tex-text, Ligatures=Rare, Numbers=OldStyle]{Linux Libertine O}
\setmathfont{Asana Math}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\lstset{
  language=[Objective]Caml,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily,
  xleftmargin=6mm,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywords=[6]{signature, structure, struct type, sig, end},
  keywordstyle=\color{MidnightBlue},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  literate=
    {->}{{$\rightharpoonup$}}{1}
    {*}{{$\otimes$}}{1}
}


\def\IModeColorName{MidnightBlue}
\def\OModeColorName{Maroon}
\newcommand\IMode[1]{{\color{\IModeColorName}{#1}}}
\newcommand\OMode[1]{{\color{\OModeColorName}{#1}}}
\newcommand\Quote[1]{{\color{Gray}{«}}#1{\color{Gray}{»}}}

\newcommand\HypJ[2]{#1\ \ (#2)}
\newcommand\GenJ[2]{\vert_{\IMode{#1}}\; #2}
\newcommand\JJ{J}
\newcommand\RSet{\mathfrak{R}}
\newcommand\JSet{\mathfrak{J}}

\newcommand\IsTac[1]{\IMode{#1}\ \textit{tactic}}

\newcommand\MkSet[1]{\left\{#1\right\}}
\newcommand\MkFam[3]{\MkSet{#1_{#2}}_{#2\in #3}}

\newcommand\IsAbt[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\OMode{#5}%
}
\newcommand\IsWf[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}\in_{\mathbf{wf}}\IMode{#5}%
}

\newcommand\IsCtx[2]{
  \IMode{#1}\ \textit{ctx}\leadsto \OMode{#2}
}
\newcommand\IsTele[2]{
  \IMode{#1}\ \textit{tele}\leadsto \OMode{#2}
}

\newcommand\SortJdg{\mathsf{jdg}}
\newcommand\MkBTm[3]{\{#1\}[#2].\, #3}
\newcommand\JdgValence[1]{\mathfrak{v}(#1)}

%% subgoals
\newcommand\ISG[2]{\IMode{#1}\,{\color{Black}:}\,\IMode{#2}}
\newcommand\OSG[2]{\IMode{#1}\,{\color{Black}:}\,\OMode{#2}}

%% refinement
\newcommand\Refine[4]{\IMode{#1}\Vdash\IMode{#2}\Rightarrow\OMode{#4}\dashv\OMode{#3}}
\newcommand\NoRefine[2]{\IMode{#1}\Vdash\IMode{#2}\Uparrow}

\newcommand\ThenMultiAux[5]{%
  \IMode{#2}\dashv\IMode{#3}%
  \Vdash^\star\IMode{#1}\Rightarrow%
  \OMode{#4}\dashv\OMode{#5}%
}

\newcommand\Member[2]{\IMode{#1}\in\IMode{#2}}
\newcommand\MemberUnmoded[2]{#1\in #2}
\newcommand\EqMemberUnmoded[3]{#1 = #2\in #3}
\newcommand\IsTrue[1]{\IMode{#1}\ \textit{true}}
\newcommand\IsTrueUnmoded[1]{#1\ \textit{true}}
\newcommand\IdTac{\mathtt{id}}
\newcommand\FailTac{\mathtt{fail}}
\newcommand\OrElseTac[2]{#1\vert#2}
\newcommand\ThenTac[2]{#1;#2}
\newcommand\ThenLTac[2]{#1;[#2]}
\newcommand\DPairIntroRule[1]{\mathtt{PairIntro}\{#1\}}
\newcommand\DPairIntroRuleNullary{\mathtt{PairIntro}}
\newcommand\DPairElimRule[1]{\mathtt{PairElim}\{#1\}}
\newcommand\DFunIntroRule{\mathtt{FunIntro}}
\newcommand\DFunElimRule[1]{\mathtt{FunElim}\{#1\}}
\newcommand\TyDPair[3]{(#2:#1) \times #3}
\newcommand\TyDFun[3]{(#2:#1) \to #3}
\newcommand\Lam[2]{\lambda(#1.#2)}
\newcommand\Ap[2]{\mathsf{ap}(#1;#2)}
\newcommand\Ax{\mathsf{Ax}}
\newcommand\Tuple[1]{\left\langle#1\right\rangle}
\newcommand\Spread[4]{\mathsf{spread}(#1;#2,#3.#4)}
\newcommand\TyUniv{\mathbb{U}}
\newcommand\TyMember[2]{#1\in#2}
\newcommand\Dom[1]{\left\vert#1\right\vert}
\newcommand\SubsetEq[2]{\IMode{#1}\subseteq\IMode{#2}}
\newcommand\FV[1]{\textit{FV}\left(#1\right)}
\newcommand\Subst[3]{\left[#1\;/\;#2\right]#3}
\newcommand\ModLCF{\textbf{\emph{Modernized LCF}}}
\newcommand\DepLCF{\textbf{\emph{Dependent LCF}}}

\newcommand\IsEquiv[2]{\IMode{#1}\equiv\IMode{#2}}

\newcommand\Seq[2]{#1 \gg #2}

\newcommand\Ext[1]{{\color{dark-gray}\left\lfloor\mathbf{ext}\ \OMode{#1}\right\rfloor}}
\newcommand\SeqExt[3]{
  \Seq{\IMode{#1}}{\IMode{#2}}\ \Ext{#3}
}
\newcommand\NuprlRule[3]{%
  \begin{array}{l}%
    #2\\
    \ \ \mathbf{by}\ #1\\
    \quad #3
  \end{array}%
}

\begin{document}

\title{Dependency in Refinement Logics}
\date{}
\author{Jonathan Sterling}
\maketitle

\begin{abstract}

  We propose a new generalization of LCF-style refinement logics called \DepLCF,
  which allows the definition of refinement rules which express a dependency
  between subgoals, without the use of unification variables.

\end{abstract}

Over the past four decades, there have been many incarnations of the \emph{LCF}
(Logic for Computable Functions) interface, but the one that will concern us
here is its extension to \emph{LCF with Validations} as found in Cambridge LCF,
which outfits the proving activity with the synthesis of explicit evidence.
The Cambridge LCF signature is as follows:

%% cite "Logic and Computation: Interactive Proof with Cambridge LCF"

\begin{lstlisting}
  signature CAMBRIDGE_LCF =
  sig
    type form
    type thm
    type proof = thm list -> thm
    type goal = form list * form
    type tactic = goal -> goal list * proof
  end
\end{lstlisting}

The \verb!goal! type represents sequents, where \verb!form! represents logical
propositions. The LCF methodology, however, may be used to give a refinement
treatment to many kinds of judgments, not just sequents; therefore, it
is better to not include this in the core signature at all, and make the
type of judgments abstract; for clarity, we will replace the name \verb!thm!
with \verb!synthesis!.

\begin{lstlisting}
  signature LCF =
  sig
    type judgment
    type synthesis
    type proof = synthesis list -> synthesis
    type tactic = judgment -> judgment list * proof
  end
\end{lstlisting}

Then, a tactic is something that refines a judgment to a list of judgments (its
subgoals), and synthesizes its evidence (provided the syntheses of its
subgoals). There are many different tactics which can be implemented
generically over this signature; here are a few:

\begin{lstlisting}
  signature TACTICALS =
  sig
    structure Lcf : LCF
    val ID : Lcf.tactic
    val FAIL : Lcf.tactic
    val THEN : Lcf.tactic * Lcf.tactic -> Lcf.tactic
    val THENL : Lcf.tactic * Lcf.tactic list -> Lcf.tactic
  end
\end{lstlisting}

\section{\ModLCF: the logic of tactics}

In order to study the design space for LCF refiners, we would like to give a
judgmental characterization of tactic systems, which we will call $\ModLCF$.
To begin with, note that the type of validations (\verb!proof!) in the ML
implementation is essentially a HOAS (higher-order abstract syntax) encoding
of a hypothetical proof or synthesis of a judgment.  With this insight in hand,
we are in a position to unify the list of subgoals and the validation generated
by a tactic into a single concept, namely that of a \emph{hypothetical proof}
$E$ whose free variables are explained in a context $\Psi$ of subgoals.

To make the preceding observations precise, we can characterize the behavior of
a \ModLCF\ refiner judgmentally via two forms of judgment,
\framebox{$\Refine{\JJ}{\tau}{\Psi}{E}$} and \framebox{$\NoRefine{\JJ}{\tau}$},
where $\JJ$ is a judgment of the logical theory, $\tau$ is a tactic, $\Psi$ is
a context of judgments, representing the subgoals generated by the tactic
$\tau$, and $E$ is the synthesis of the judgment $\JJ$, binding variables
$\Dom{\Psi}$ which represent the syntheses of the subgoals.

The meaning of $\Refine{\JJ}{\tau}{\Psi}{E}$ is that $\tau$ is applicable to
demonstrating the judgment $\JJ$, producing synthesis $E$ under the assumptions
that the judgments in $\Psi$ can be demonstrated. The divergence judgment
$\NoRefine{\JJ}{\tau}$ expresses the inapplicability of $\tau$ to $\JJ$. In
practice, we will explain only the assertion conditions for one of
$\Refine{\JJ}{\tau}{\Psi}{E}$ and $\NoRefine{\JJ}{\tau}$, and implicitly take
the other to be its complement.

\begin{remark}
  The refinement judgments $\Refine{\JJ}{\tau}{\Psi}{E}$ and
  $\NoRefine{\JJ}{\tau}$ are not higher-order judgments, because the variable
  $\JJ$ ranges not over judgments of the refinement theory, but of the
  object theory.
\end{remark}

In order to properly treat generic judgments whose syntheses bind variables, we
will commit up front to using the abstract binding trees logical framework as a
universal domain of discourse, with a distinguished sort $\SortJdg$ for
object-judgments; and to each judgment $\JJ$ such that
$\IsWf{\Omega}{\Upsilon}{\Gamma}{\JJ}{\SortJdg}$, a \emph{valence}
$\JdgValence{\JJ}$ shall be associated which describes the binding structure of
its synthesis.

Then, we will need to define the wellformedness of subgoal contexts $\Psi$,
simultaneously associating to $\Psi$ a metavariable context $\Omega$ which will
stand for the collected syntheses of $\Psi$:
\begin{gather*}
  \infer{
    \IsCtx{\cdot}{\cdot}
  }{
  }\qquad
  \infer{
    \IsCtx{\Psi,\alpha:\JJ}{\Omega,\alpha:\JdgValence{\JJ}}
  }{
    \IsCtx{\Psi}{\Omega} &
    \IsWf{\cdot}{\cdot}{\cdot}{\JJ}{\SortJdg}
  }
\end{gather*}

\begin{remark}
  Note how the context-wellformedness judgment artificially requires that $\JJ$
  be wellformed in the empty metavariable context.
\end{remark}

Then, the judgments $\NoRefine{\JJ}{\tau}$ and $\Refine{\JJ}{\tau}{\Psi}{E}$
shall presuppose $\IsWf{\cdot}{\cdot}{\cdot}{\JJ}{\SortJdg}$, and the latter
shall postsuppose $\IsCtx{\Psi}{\Omega}$ and $\IsWf{\Omega}{\cdot}{\cdot}{E}{\JdgValence{\JJ}}$.
When $E$ binds no variables or symbols, we shall write $E$ instead of
$\MkBTm{\cdot}{\cdot}{E}$.

Let $\JSet$ be the set $\MkSet{\JJ\mid\IsWf{\cdot}{\cdot}{\cdot}{\JJ}{\SortJdg}}$,
and let $\RSet$ be a collection of rule names. Each rule $\Member{R}{\RSet}$
must be interpretable as a tactic, i.e.\ the meaning of the assertions
$\Refine{\JJ}{R}{\Psi}{E}$ and $\NoRefine{\JJ}{R}$ must be explained for
$\Member{J}{\JSet}$. We say \framebox{$\IsTac{\tau}$} in case for all
object-judgments $\Member{\JJ}{\JSet}$, the assertion conditions for
$\Refine{\JJ}{\tau}{\Psi}{E}$ and $\NoRefine{\JJ}{\tau}$ are well-defined and
disjoint.

Numerous general purpose tactics can be defined over a logical theory,
including identity, failure, disjunction and sequencing:

\begin{gather*}
  \infer{
    \Refine{\JJ}{\IdTac}{\OSG{\alpha}{\JJ}}{\alpha}
  }{
  }
  \qquad
  \infer{
    \NoRefine{\JJ}{\FailTac}
  }{
  }\\[6pt]
  \infer{
    \Refine{\JJ}{\OrElseTac{\tau_1}{\tau_2}}{\Psi}{E}
  }{
    \Refine{\JJ}{\tau_1}{\Psi}{E}
  }
  \qquad
  \infer{
    \Refine{\JJ}{\OrElseTac{\tau_1}{\tau_2}}{\Psi}{E}
  }{
    \NoRefine{\JJ}{\tau_1} &
    \Refine{\JJ}{\tau_2}{\Psi}{E}
  }\\[6pt]
  \infer{
    \Refine{\JJ}{\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{\Dom\Phi}}}{\bigoplus_{\Dom\Phi}\mathbf\Psi}{\Subst{F}{\Dom\Phi}{E}}
  }{
    \Refine{\JJ}{\tau_1}{\Phi}{E} &
    \GenJ{\alpha}{
      \HypJ{
        \Refine{\Phi(\alpha)}{\tau_\alpha}{\Psi_\alpha}{F_\alpha}
      }{
        \Member{\alpha}{\Dom\Phi}
      }
    }
  }
\end{gather*}

\begin{remark}
  The nominal treatment that we have given here allows for a much more
  economical presentation of the standard tacticals, which are quite ardruous
  to define in the HOAS treatment used in ML implementations.
\end{remark}

The sequencing tactical
$\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{I}}$ corresponds to
\verb!THENL! in LCF; the uniform sequencing tactical \verb!THEN! may be
recovered as a definitional extension, with its second argument given as the
constant family:
\[
    \IMode{\ThenTac{\tau_1}{\tau_2}}
    \triangleq
    \OMode{\ThenTac{\tau_1}{\MkSet{\tau_2}}}
\]

\begin{thm}
  The above rules all define valid tactics.
  \begin{enumerate}
    \item $\IsTac{\IdTac}$.
    \item $\IsTac{\FailTac}$.
    \item If $\IsTac{\tau_1}$ and $\IsTac{\tau_2}$, then
      $\IsTac{\OrElseTac{\tau_1}{\tau_2}}$.

    \item If $\IsTac{\tau_1}$ and for any $\Member{\alpha}{I}$,
      $\IsTac{\tau_\alpha}$, then
      $\IsTac{\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{I}}}$.
  \end{enumerate}
\end{thm}
\begin{proof}
  Disjointness for each tactical is immediately evident; it suffices, then, to
  verify the postsuppositions $\IsCtx{\Psi}{\Omega}$ and
  $\IsWf{\Omega}{\cdot}{\cdot}{E}{\JdgValence{\JJ}}$ in each case.
  \begin{enumerate}
    \item[(1--2)] Immediate.
    \item[(3)]
      By induction on derivations of
      $\Refine{\JJ}{\OrElseTac{\tau_1}{\tau_1}}{E}{\Psi}$.
      \begin{description}
        \item[Case $\Refine{\JJ}{\tau_1}{\Psi}{E}$.] Validity follows from the
          inductive hypothesis $\IsTac{\tau_1}$.
        \item[Case $\NoRefine{\JJ}{\tau_1}$.] Validity follows from the
          inductive hypothesis $\IsTac{\tau_2}$.
      \end{description}

    \item[(4)] It suffices to verify the cases where
      $\IsEquiv{\Dom\Phi}{I}$, since otherwise
      $\NoRefine{\JJ}{\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{I}}}$.
      We need to show that
      $\SubsetEq{\FV{\Subst{F}{\Dom\Phi}{E}}}{\Dom{\bigoplus_{\Dom\Phi}\Psi}}$.
      From our inductive hypotheses, it is evident that
      $\SubsetEq{\FV{E}}{\Dom\Phi}$ and that for each $\Member{\alpha}{\Phi}$,
      $\SubsetEq{\FV{F_\alpha}}{\Dom{\Psi_\alpha}}$; all of the free metavariables
      of the term got by substituting each $F_\alpha$ for
      $\Member{\alpha}{\Dom\Phi}$ clearly reside in one of the fibres of the
      family of contexts $\Psi$, and so they must comprise a subset of the
      union $\bigoplus_{\Dom\Phi}\Psi$ of $\Psi$'s fibres.

  \end{enumerate}
\end{proof}

\section{\ModLCF\ and the constructible subgoals property}

An LCF-style refiner has a property called \emph{constructible subgoals}, which
means that the subgoals incurred by a rule or tactic may be constructed
independently, using only the statement of the main goal. One unfortunate
consequence of this principle is that it is impossible to define a refinement
rule which expresses a dependency between subgoals. The canonical example is
the introduction rule for dependent pairs in Type Theory:
\[
  \infer[\textit{PairIntro}]{
    \Member{\Tuple{M,N}}{\TyDPair{A}{x}{B}}
  }{
    \Member{M}{A} &
    \Member{N}{\Subst{M}{x}{B}}
  }
\]

However, consider what a refinement rule for this would look like; we would
like to take the goal $\IsTrue{\TyDPair{A}{x}{B}}$ to two subgoals (one for
each conjunct); the first subgoal $\IsTrue{A}$ is clear enough, but it is not
possible to even write down the second subgoal until we know the synthesis of
the first one.

Because a tactic in \ModLCF\ produces only a \emph{context} of independent
subgoals, we cannot give a refinement treatment to this rule, and must
instead write a family of refinement rules $\DPairIntroRule{w}$ fibred over
witnesses of the left conjunct $w$:

\[
  \Refine{\IsTrueUnmoded{\TyDPair{A}{x}{B}}}{\DPairIntroRule{w}}{%
    \left\{\begin{array}{l}
      \OSG{\alpha}{\MemberUnmoded{w}{A}}\\
      \OSG{\beta}{\IsTrueUnmoded{\Subst{w}{x}{B}}}
    \end{array}\right.
  }{\Tuple{w,\beta}}
\]

This is clearly unsatisfactory, since it breaks the natural flow of proof
development, whereby multiple goals may be refined simultaneously without
committing in advance to a particular solution. However, a more palatable
rule that allows $\IsTrue{A}$ to be demonstrated by refinement is
simply not expressible in \ModLCF, since the sense of the second subgoal cannot
be expressed except by referring to the synthesis of the first subgoal.

\section{\DepLCF\ and generalized refinement rules}

At the crux of our problem is the fact that a tactic produces a context of subgoals
without any dependencies; if we were to construe the judgment
$\Refine{\JJ}{\tau}{\Psi}{E}$ as synthesizing a \emph{telescope} $\Psi$ rather
than a mere context, a proper refinement rule for \emph{PairIntro} would be
within reach. In fact, whilst the ML signature for LCF refiners rules out this
interpretation, the notation we have used for \ModLCF\ immediately suggests
this generalization. Going forward, we will call the theory \DepLCF\ when we
take $\Psi$ to be a telescope rather than a context.

Briefly, we can adjust the postsuppositions of the refinement judgment to
account for this generalization, by first characterizing the wellformed
telescopes:
\begin{gather*}
  \infer{
    \IsTele{\cdot}{\cdot}
  }{
  }\qquad
  \infer{
    \IsTele{\Psi,\alpha:\JJ}{\Omega,\alpha:\JdgValence{\JJ}}
  }{
    \IsTele{\Psi}{\Omega} &
    \IsWf{\Omega}{\cdot}{\cdot}{\JJ}{\SortJdg}
  }
\end{gather*}

Now, $\Refine{\JJ}{\tau}{\Psi}{E}$ shall postsuppose $\IsTele{\Psi}{\Omega}$
and $\IsWf{\Omega}{\cdot}{\cdot}{E}{\JdgValence{\JJ}}$.

\subsection{Dependent Tacticals}
All that remains is to give a new definition of the sequencing tactical
$\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{I}}$ which accounts for this dependency.
To this end, we will need to implement an auxiliary judgment
\framebox{$\ThenMultiAux{\MkFam{\tau}{\alpha}{I}}{E}{\Phi}{E'}{\Phi'}$} that
allows us to apply the family of tactics $\MkFam{\tau}{\alpha}{I}$ pointwise to
a proof state, simultaneously propagating refinements rightward through
metavariable substitution. This judgment, which presupposes
$\IsEquiv{I}{\Dom\Phi}$, is defined by recursion on the telescope $\Phi$,
viewed as a \emph{cons}-list:

\begin{gather*}
  \infer{
    \ThenMultiAux{\MkSet{}}{E}{\cdot}{E}{\cdot}
  }{
  }\\[6pt]
  %
  \infer{
    \ThenMultiAux{
      \MkFam{\tau}{\beta}{\MkSet{\alpha}\cup\Dom\Phi}
    }{E}{
      \ISG{\alpha}{\JJ},\Phi
    }{E'}{
      \Psi_\alpha\oplus\Phi'
    }
  }{
    \Refine{\JJ}{\tau_\alpha}{\Psi_\alpha}{E_\alpha} &
    \ThenMultiAux{
      \MkFam{\tau}{\beta}{\Phi}
    }{
      \Subst{E_\alpha}{\alpha}{E}%
    }{
      \Subst{E_\alpha}{\alpha}{\Phi}
    }{E'}{\Phi'}
  }
\end{gather*}

Now, the sequencing tactical is readily definable, presupposing $\IsEquiv{I}{\Dom\Phi}$:
\[
  \infer{
    \Refine{\JJ}{\ThenTac{\tau_1}{\MkFam{\tau}{\alpha}{I}}}{\Phi'}{E'}
  }{
    \Refine{\JJ}{\tau_1}{\Phi}{E} &
    \ThenMultiAux{
      \MkFam{\tau}{\alpha}{I}
    }{E}{\Phi}{E'}{\Phi'}
  }
\]

\section{Case Study: Constructive Type Theory}

%%% TODO: correct to use new metavariable kit!!

The refinement logic for CTT is a sequent calculus with a single form of
judgment, \framebox{$\Seq{\IMode{H}}{\IMode{P}}$}, which means that the
proposition $P$ is true (and functionally so) under the assumptions in the
telescope $H$. The synthesis of this judgment is a hypothetical witness for the
truth or $P$ (or \emph{extract term}) with free variables bound in $H$.

The type theory CTT is then approximated in the refinement logic by adding
valid refinement rules for $\Seq{\IMode{H}}{\IMode{P}}$. For the sake of
familiarity, we will re-use Nuprl's rule notation such that
\[
  \NuprlRule{\texttt{RuleName}}{
    \SeqExt{H}{P}{E(\alpha_0,\alpha_1,\dots,\alpha_n)}
  }{
    \begin{array}{l}
      \SeqExt{H_0}{Q_0}{\alpha_0}\\
      \SeqExt{H_1(\alpha_0)}{Q_1(\alpha_0)}{\alpha_1(\alpha_0)}\\
      \vdots\\
      \SeqExt{H_n(\alpha_0,\alpha_1,\dots,\alpha_{n-1})}{Q_n(\alpha_0,\alpha_1,\dots,\alpha_{n-1})}{\alpha_n(\alpha_0,\dots,\alpha_{n-1})}
    \end{array}
  }
\]
shall mean
\[
  \Refine{
    \Seq{H}{P}
  }{
    \mathtt{RuleName}
  }{
    \left\{\begin{array}{l}
      \OSG{\alpha_0}{\Seq{H_0}{Q_0}}\\
      \OSG{\alpha_1}{\Seq{H_1}{Q_1}}\\
      \multicolumn{1}{c}{\color{Black}\vdots}\\
      \OSG{\alpha_n}{\Seq{H_n}{Q_n}}\\
    \end{array}\right.
  }{
    E(\alpha_0,\alpha_1,\dots,\alpha_n)
  }
\]


Let us first give some of the refinement rules for the dependent pair type:

\[
  \begin{array}{l}
    \NuprlRule{\DPairIntroRuleNullary}{
      \SeqExt{H}{\TyDPair{A}{x}{B}}{\Tuple{\alpha,\beta}}
    }{
      \begin{array}{l}
        \SeqExt{H}{A}{\alpha}\\
        \SeqExt{H}{\Subst{\alpha}{x}{B}}{\beta}\\
        \SeqExt{H,x:A}{\MemberUnmoded{B}{\TyUniv}}{\gamma(x)}
      \end{array}
    }\\\\
    \NuprlRule{\DPairElimRule{z}}{
      \SeqExt{H,z:\TyDPair{A}{x}{B},J}{C}{
        \Spread{z}{u}{v}{\alpha(u,v)}
      }
    }{
      \SeqExt{H,z:\TyDPair{A}{x}{B},u:A,v:\Subst{u}{x}{B},\Subst{\Tuple{u,v}}{z}{J}}{C}{
        \alpha(u,v)
      }
    }
  \end{array}
\]

We can also give refinement rules for dependent function introduction and
elimination; in the same way \ModLCF\ could not express a refinement rule for
pair introduction, a refinement rule for function elimination likewise only
becomes attainable via the generalization to \DepLCF.

\[
  \begin{array}{l}
    \NuprlRule{\DFunIntroRule}{
      \SeqExt{H}{\TyDFun{A}{x}{B}}{\Lam{x}{\alpha(x)}}
    }{
      \begin{array}{l}
        \SeqExt{H,x:A}{B}{\alpha(x)}\\
        \SeqExt{H}{\MemberUnmoded{A}{\TyUniv}}{\beta}
      \end{array}
    }\\\\
    \NuprlRule{\DFunElimRule{z}}{
      \SeqExt{
        H,z:\TyDFun{A}{x}{B},J
      }{C}{
        \beta(\Ap{z}{\alpha}, \Ax)
      }
    }{
      \begin{array}{l}
        \SeqExt{H,z:\TyDFun{A}{x}{B}, J}{A}{\alpha}\\
        \SeqExt{
          H,z:\TyDFun{A}{x}{B},%
          y:\Subst{\alpha}{x}{B},%
          p:\EqMemberUnmoded{y}{\Ap{z}{\alpha}}{\Subst{\alpha}{x}{B}}, J
        }{C}{
          \beta(y,p)
        }
      \end{array}
    }
  \end{array}
\]

\end{document}
